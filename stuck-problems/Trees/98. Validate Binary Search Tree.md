# 98. Validate Binary Search Tree

**LeetCode:** {https://leetcode.com/problems/validate-binary-search-tree/description/}  
**Date:** {2026-01-27}  
**Status:** âŒ Stuck / ðŸ” Redo  
**Difficulty:** Medium
**Tags/Pattern:** {trees}  
**Time/Space:** O(n) / O(log h)

---

## 1) Problem in 1 line

all the nodes on left subtree should be lesser in value than root and right subtree strictly greater
Explain the problem in one sentence.

---

## 2) My first thought (before coding)

should use a function but nothing more than that
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook í•µì‹¬)

- Mistake #1: defining low, high
- Mistake #2:return cases in function
- What I learned:
- return case is based on what you want it to return when there is no node for example

---

## 4) Final approach (in plain English)

- define function with node,low,high
- if not node return none so backtrack happens
- if node.val out of bound limits of low and high return false
- define leftsubtree= with function to traverse for left subtree and same on right
- return for this funciton is leftsubtree and rightsubtree
- call the above function as return for the main function
  Steps of the solution like youâ€™d explain to a friend.

---

## 5) Code (final)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:

        def valid(node,low,high):
            if not node:
                return True
            if not (low<node.val<high):
                return False
            left_subtree=valid(node.left, low, node.val)
            right_subtree=valid(node.right, node.val, high)
            return left_subtree and right_subtree

        return valid(root,float('-inf'),float('inf'))
# paste final accepted code here
```
