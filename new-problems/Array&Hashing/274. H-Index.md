# 274. H-Index

**LeetCode:** {https://leetcode.com/problems/h-index/?envType=study-plan-v2&envId=top-interview-150}  
**Date:** {2026-02-04}  
**Status:** âŒ Stuck / ğŸ” Redo  
**Difficulty:** Medium
**Tags/Pattern:** {arrays, hashing}  
**Time/Space:** O(n log n) / O(1)

---

## 1) Problem in 1 line

- you have to find min number of papers that have number of papers citations
  Explain the problem in one sentence.

---

## 2) My first thought (before coding)

- i wanted to create freq map, sort frequencies and compare len of array-each iteration>freq[i]
  What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook í•µì‹¬)

- Mistake #1: reverse sort the array?
- What I learned:
- arr.sort(reverse=True)
- â€œFind the biggest number h such that at least h papers have at least h citations each.â€

---

## 4) Final approach (in plain English)

- First, understand the goal: we want the largest number h where at least h papers have â‰¥ h citations.
- Sort the citations in descending order so the most cited papers come first.
- Now walk through the list and treat the index as â€œhow many papers we have seen so farâ€.
- For each position, check: does this paper have at least (index + 1) citations? If yes, we can increase h.
- The moment this fails, stop, because all later papers will have even fewer citations.
- The last valid count you reached is your h-index.
  Steps of the solution like youâ€™d explain to a friend.

---

## 5) Code (final)

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        citations.sort(reverse=True)
        h=0
        for i,c in enumerate(citations):
            if c>=i+1:
                h=i+1
            else:
                break
        return h
# paste final accepted code here
```
