# 235. Lowest Common Ancestor of a Binary Search Tree

**LeetCode:** {https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/}  
**Date:** {2026-01-27}  
**Status:** âŒ Stuck / ðŸ” Redo  
**Difficulty:** Medium
**Tags/Pattern:** {trees}  
**Time/Space:** O(n) / O(1)

---

## 1) Problem in 1 line

find the common most least ancestor to the two node values given as p and q
Explain the problem in one sentence.

---

## 2) My first thought (before coding)

thought of using helper function, and .val to grab values of the nodes, edge case if not root then return None
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook í•µì‹¬)

- Mistake #1: did not think if p,q are greater than root node which is curr as we keep changing its value then its right subtree
- Mistake #2: binary search tree was hint to think this way
- What I learned:
- usage of while loop without need of helper function for recursion

---

## 4) Final approach (in plain English)

- if not root return None
- while root if both nodes greater then curr node then root=root.right as right subtree has viable options
- elif nodes are lower than curr node value then left subtree has viable options
- else return root
  Steps of the solution like youâ€™d explain to a friend.

---

## 5) Code (final)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:
            return None
        while root:
            if root.val<p.val and root.val<q.val:
                root=root.right
            elif root.val>p.val and root.val>q.val:
                root=root.left
            else:
                return root
# paste final accepted code here
```
