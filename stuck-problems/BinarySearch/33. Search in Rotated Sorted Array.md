# 33. Search in Rotated Sorted Array

**LeetCode:** {https://leetcode.com/problems/search-in-rotated-sorted-array/description/}  
**Date:** {2026-01-21}  
**Status:** âŒ Stuck / ğŸ” Redo  
**Difficulty:** Medium
**Tags/Pattern:** {binary search}  
**Time/Space:** O(log n) / O(1)

---

## 1) Problem in 1 line

find the index of the element equal to target given as input
Explain the problem in one sentence.

---

## 2) My first thought (before coding)

i did binary search and was trying to compare nums[mid] with nums[left] and nums[right] in if else conditions
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook í•µì‹¬)

- Mistake #1: should take if else for left sorted or right sorted half of the arrays
- Mistake #2: left<=right not left< right as checking equalities here
- Mistake #3: nums[left]<=target< nums[mid] equality is imp here
- Mistake #4: nums[mid]<target =< nums[right] is imp
- What I learned:
- ğŸ”‘ Rule of thumb (memorize this)
- If you are explicitly checking nums[mid] == target, use left <= right.
- If you are shrinking toward a boundary answer, use left < right.

---

## 4) Final approach (in plain English)

- take left, right, mid, check if target ==nums[mid]
- if not go to left sorted array and check nums[left] <= nums[mid] then if nums[left]<=target< nums[mid] leads to right=mid-1 else left=mid+1
- else to above if then if nums[mid]<target =< nums[right] leads to left=mid+1 else right=mid-1
- return -1 outside the while if target not found
  Steps of the solution like youâ€™d explain to a friend.

---

## 5) Code (final)

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left=0
        right=len(nums)-1
        if len(nums)==1 and target==nums[0]:
            return 0
        while left<=right:
            mid=(left+right)//2
            if nums[mid]==target:
                return mid
            #left half sorted
            if nums[left]<=nums[mid]:
                if nums[left]<=target<nums[mid]:
                    right=mid-1
                else:
                    left=mid+1
            else:
                if nums[mid]<target<=nums[right]:
                    left=mid+1
                else:
                    right=mid-1
        return -1

# paste final accepted code here
```
