# 125. Valid Palindrome

**LeetCode:** https://leetcode.com/problems/valid-palindrome/description/
**Date:** 2026-01-18, 2026-02-03
**Status:** ✅ Stuck
**Difficulty:** Easy
**Tags/Pattern:** two pointers
**Time/Space:** O(n), O(n)

---

## 1) Problem in 1 line

string should be same from first to last

---

## 2) My first thought (before coding)

i made string lowercase
used pointers
used if for every condition
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook 핵심)

- mistake #attempt2: did not how to check if not s[pointer].isalnum()
- Mistake #1: forgot about return stmt
- Mistake #2: dont know syntax for lowercasing the string but increases tc here so check each character ex - s[left].lower()
  -Mistake #3: when to increment pointers not in common while loop only if chars are same increment both the pointers
- What I learned:
  to lowercase whole string: s=s.lower()
  use if else than just if to make it more easier
  to check alphanumeric characters: for ex: s[left].isalnum()

---

## 4) Final approach (in plain English)

make string lowercase
define left right pointers
use while loop left<right
if both chars same increment left, right
elif check if not alphanum then increment respective pointer
else if chars not same then return false
out of common while return true
Steps of the solution like you’d explain to a friend.

---

## 5) Code (final)

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        #change to lowercase
        #remove non alphanumeric characters
        left=0
        right=len(s)-1
        s=s.lower()
        while left<right:
            if s[left]==s[right]:
                left+=1
                right-=1
            elif not s[left].isalnum():
                left+=1
            elif not s[right].isalnum():
                right-=1
            else: #s[left]!=s[right]
                return False
        return True

# paste final accepted code here
```
