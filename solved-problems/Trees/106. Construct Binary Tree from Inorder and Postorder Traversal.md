# 106. Construct Binary Tree from Inorder and Postorder Traversal

**LeetCode:** {https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/}  
**Date:** {2026-01-28}  
**Status:** ✅ Solved
**Difficulty:** Medium
**Tags/Pattern:** {Trees}  
**Time/Space:** O(n^2) / O(h)

---

## 1) Problem in 1 line

return a normal tree from the inorder and postorder traversal given as input
Explain the problem in one sentence.

---

## 2) My first thought (before coding)

i know the approach as i solved similar problem recently
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook 핵심)

- Mistake #1: a bit confused about how to track right subtree from inorder and preorder but figured it out with examples

---

## 4) Final approach (in plain English)

- if not inorder or not postorder return None
- get root from postorder last eleemnt
- get mid to split the lists given to build new tree from using postorder final element to find index of it in inorder list
- assign right=mid+1 to get right subtree from postorder as it is left right root so a bit tricky
- get root.left and root.right using self of the given function and slice indexes based on inorder and postorder
- return root
  Steps of the solution like you’d explain to a friend.

---

## 5) Code (final)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not inorder or not postorder:
            return None

        root=TreeNode(postorder[-1])
        mid=inorder.index(postorder[-1])
        right=mid+1
        root.left=self.buildTree(inorder[0:mid], postorder[0:mid])
        root.right=self.buildTree(inorder[mid+1:], postorder[mid:-1])
        return root

# paste final accepted code here
```
