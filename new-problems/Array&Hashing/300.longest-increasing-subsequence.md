# 300. Longest Increasing Subsequence

**LeetCode:** {https://leetcode.com/problems/longest-increasing-subsequence/description/}  
**Date:** {2026-01-15}  
**Status:** ❌ Stuck
**Difficulty:** Medium  
**Tags/Pattern:** {e.g., Hashing, Set, DP}  
**Time/Space:** O(?) / O(?)

---

## 1) Problem in 1 line

find the longest increasing sequence: as longest and you have to make decision based on past it is a typical dp problem
Explain the problem in one sentence.

---

## 2) My first thought (before coding)

i thought of doing it like consequetive numbers using sets with modifications
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook 핵심)

- Mistake #1: couldnt identify it is dp problem
- Mistake #2: did not know how to code dp solution
- What I learned:
  dp methodology and identification based on the problem discussion
  take dp array and initialize with 0/1 using len of input
  now use for loops to navigate the input and solve the problem

---

## 4) Final approach (in plain English)

initialise array called dp with 1 as value and of length of input array
now take for loop with i as index in range of input array length
now take second for loop in first for loop with j as index and in range of i and do dp modifications only when nums[i]>nums[j] as we consider nums[i] as the last element in increasing sequence so this is every state
dp modifications are finding max length by doing dp[i]=max(dp[i], dp[j]+1)
return max(dp) - return max value in dp array
Steps of the solution like you’d explain to a friend.

---

## 5) Code (final)

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp=[1]*len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i]>nums[j]:
                    dp[i]=max(dp[i], dp[j]+1)
        return max(dp)

# paste final accepted code here
```
