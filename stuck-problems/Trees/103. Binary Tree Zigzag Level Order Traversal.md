# 103. Binary Tree Zigzag Level Order Traversal

**LeetCode:** {https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/}  
**Date:** {2026-01-29}  
**Status:** âŒ Stuck / ðŸ” Redo  
**Difficulty:** Medium
**Tags/Pattern:** {trees}  
**Time/Space:** O(n) / O(n)

---

## 1) Problem in 1 line

odd levels -> left to right, even lefts reverse
Explain the problem in one sentence.

---

## 2) My first thought (before coding)

i thought of using global variable to shift directions and use dfs, helper function, tracking len of res array with depth
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook í•µì‹¬)

- Mistake #1: thought of treating bfs problem like dfs
- Mistake #2:
- What I learned:
- bfs so use deque and popleft
- use variable for direction
- array.reverse() reverses direction of the elements in the array

---

## 4) Final approach (in plain English)

- if not root return []
- take queue as deque with root value
- assign left to right var as true
- while queue: level_nodes=[], level_size=len(queue)
- pop elemenet from queue to keep it in level nodes and take it as node value now traverse left and right and add children into queue
- check direction, reverse level nodes if needed then add level nodes array into res list
- change direction
- return res list
  Steps of the solution like youâ€™d explain to a friend.

---

## 5) Code (final)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        queue=deque([root])
        result=[]
        left_to_right=True
        while queue:
            level_nodes=[]
            level_size=len(queue)
            for _ in range(level_size):
                node=queue.popleft()
                level_nodes.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            if not left_to_right:
                level_nodes.reverse()
            result.append(level_nodes)
            left_to_right=not left_to_right
        return result

# paste final accepted code here
```
