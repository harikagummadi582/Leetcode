# 105. Construct Binary Tree from Preorder and Inorder Traversal

**LeetCode:** {https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/}  
**Date:** {2026-01-28}  
**Status:** âŒ Stuck / ðŸ” Redo  
**Difficulty:** Medium
**Tags/Pattern:** {Trees}  
**Time/Space:** O(n^2) / O(n)

---

## 1) Problem in 1 line

construct the normal tree from preorder and inorder traversals given as input
Explain the problem in one sentence.

---

## 2) My first thought (before coding)

i know how to get root out of preorder that is it. i searched brute force and got to know i have to slice based on the root but not sure how
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook í•µì‹¬)

- Mistake #1: used for loops to build a list to return but we should build a tree so had to use TreeNode function given in the solution space
- Mistake #2:basecase if either of tree doesnt exist return None
- What I learned:
- you should build a tree and return it not build a list/array to return as an output
- list.index(element) gives you the index of the element in the list
- root.left and root.right built from the given function and slicing based on the root found

---

## 4) Final approach (in plain English)

- if either of preorder or inorder doesnt exist return None
- find mid from inorder index or preorder first element as that is the index
- assign root value using TreeNode built in function(first element of preorder)
- root.left build using self of given function (preorder slice based on index, inorder slice based on index)
- build root.right similarly
- return root
  Steps of the solution like youâ€™d explain to a friend.

---

## 5) Code (final)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not inorder:
            return None
        mid= inorder.index(preorder[0])
        root=TreeNode(preorder[0])
        root.left=self.buildTree(preorder[1:mid+1], inorder[0:mid])
        root.right=self.buildTree(preorder[mid+1:], inorder[mid+1: ])
        return root
# paste final accepted code here
```
