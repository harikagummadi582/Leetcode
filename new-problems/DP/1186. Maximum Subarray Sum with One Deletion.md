# 1186. Maximum Subarray Sum with One Deletion

**LeetCode:** {https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/description/?envType=company&envId=two-sigma&favoriteSlug=two-sigma-all}  
**Date:** {2026-01-21}  
**Status:** âŒ Stuck / ðŸ” Redo  
**Difficulty:** Medium
**Tags/Pattern:** {Arrays, DP}  
**Time/Space:** O(n) / O(1)

---

## 1) Problem in 1 line

find the max array with one deletion or no deletion
Explain the problem in one sentence.

---

## 2) My first thought (before coding)

no fucking idea
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook í•µì‹¬)

- Mistake #1: kadanes algorithm not known
- What I learned: Kadaneâ€™s Algorithm finds the maximum sum of a contiguous subarray by keeping a running sum. Whenever the running sum becomes negative, reset it to the current element, since a negative sum only reduces future subarrays.

---

## 4) Final approach (in plain English)

- max_no_delete â€“ the best subarray sum ending here if we donâ€™t delete anything (normal Kadane).
- max_one_delete â€“ the best subarray sum ending here if we already deleted one element somewhere.
- prev_no_delete â€“ the previous stepâ€™s max_no_delete, saved so we can skip the current element if needed.
- result â€“ the maximum answer seen so far, across all positions and cases.
- arr[i] â€“ the current number we either add to a subarray or delete (skip) to improve the sum.
  Steps of the solution like youâ€™d explain to a friend.

---

## 5) Code (final)

```python
class Solution:
    def maximumSum(self, arr: list[int]) -> int:
        n = len(arr)
        if n == 1:
            return arr[0]

        # max_no_delete: Max sum ending at i without any deletions (Kadane's).
        max_no_delete = arr[0]

        # max_one_delete: Max sum ending at i with exactly one deletion.
        max_one_delete = arr[0]
        result = arr[0]

        for i in range(1, n):
            prev_no_delete = max_no_delete

            # Standard Kadane: extend previous or start new.
            max_no_delete = max(max_no_delete + arr[i], arr[i])

            # One-deletion logic:
            # 1. Use existing deletion and keep current element.
            # 2. Skip current element (use prev_no_delete).
            max_one_delete = max(max_one_delete + arr[i], prev_no_delete)

            result = max(result, max_no_delete, max_one_delete)

        return result
# paste final accepted code here
```
