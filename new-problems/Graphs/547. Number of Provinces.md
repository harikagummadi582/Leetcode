# 547. Number of Provinces

**LeetCode:** {https://leetcode.com/problems/number-of-provinces/description/?envType=company&envId=two-sigma&favoriteSlug=two-sigma-all}  
**Date:** {2026-01-21}  
**Status:** âŒ Stuck / ðŸ” Redo  
**Difficulty:** Medium  
**Tags/Pattern:** {Graphs}  
**Time/Space:** O(?) / O(?)

---

## 1) Problem in 1 line

Given a connectivity matrix between cities, the problem is to count how many distinct connected groups (provinces) exist, where each group consists of cities directly or indirectly connected to each other.
Explain the problem in one sentence.

---

## 2) My first thought (before coding)

no idea at all
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook í•µì‹¬)

- Mistake #1:
- Mistake #2:
- What I learned:

---

## 4) Final approach (in plain English)

- video reference: {https://youtu.be/UgBcBFRatDU?si=iEX0UVBIuK1a0UHg}
- go to each node and check if it is visited if visited skip if not take neighbours and check if they are visited or not and the connection between the node and the neighbour.
- Think of each city as a dot, and a 1 in the matrix as a road connecting two cities.
- Keep a visited list so you remember which cities youâ€™ve already explored.
- Start from a city you havenâ€™t visited yet â€” that means youâ€™ve found a new province.
- Use DFS to travel from that city to all other cities connected to it, marking them visited as you go.
- Once DFS finishes, you know the entire province is covered, so you move on to find the next unvisited city.
- Count how many times you had to start DFS â€” that count is the number of provinces.

Steps of the solution like youâ€™d explain to a friend.

---

## 5) Code (final)

```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        n=len(isConnected)
        provinces=0
        visited=[False]*n

        def dfs(node):
            visited[node]=True
            for neighbour in range(n):
                if isConnected[node][neighbour]==1 and not visited[neighbour]:
                    dfs(neighbour)

        for i in range(n):
            if not visited[i]:
                dfs(i)
                provinces+=1
        return provinces


# paste final accepted code here
```
