# 289. Game Of Life

**LeetCode:** {https://leetcode.com/problems/game-of-life/description/?envType=company&envId=two-sigma&favoriteSlug=two-sigma-all}  
**Date:** {2026-01-22}  
**Status:** ‚ùå Stuck / üîÅ Redo  
**Difficulty:** Medium  
**Tags/Pattern:** {Arrays, Matrix}  
**Time/Space:** O(?) / O(?)

---

## 1) Problem in 1 line

Update the Game of Life board in-place so every cell becomes alive/dead based on how many live neighbors it had in the original board state.
Explain the problem in one sentence.

---

## 2) My first thought (before coding)

no idea
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook ÌïµÏã¨)

- Mistake #1:Built copy_board with a flattened comprehension:
  [[board[r][c]] for r in range(rows) for c in range(cols)] this makes a (rows\*cols) x 1 list (each row has only 1 element), not a rows x cols grid, so copy_board[r][c] causes IndexError.
- Mistake #2: Used == instead of = when updating:board[row][col] == 0
- What I learned: For grid simulations, either (A) read from a separate copy and write to the original, or (B) use in-place markers so reads still reflect the old stat

---

## 4) Final approach (in plain English)

- Make a true 2D copy of the board so I can safely read the ‚Äúold‚Äù state.
- For each cell, count live neighbors using the 8 direction offsets (only inside bounds).
- Apply rules:
- Live cell dies if neighbors <2 or >3
- Dead cell becomes live if neighbors == 3
- Otherwise it stays the same
- Write updates to board while always checking neighbors from copy_board.
  Steps of the solution like you‚Äôd explain to a friend.

---

## 5) Code (final)

```python
class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """

        neighbours=[(-1,-1), (-1,0), (1,-1), (0,-1), (0,1), (-1,1), (1,1), (1,0)]
        rows=len(board)
        cols=len(board[0])
        copy_board=[[board[row][col] for col in range(cols)] for row in range(rows) ]
        for row in range(rows):
            for col in range(cols):
                live_neighbours=0
                for neighbour in neighbours:
                    row_change=(row+neighbour[0])
                    col_change=(col+neighbour[1])


                    if (row_change<rows and row_change>=0) and (col_change<cols and col_change>=0) and (copy_board[row_change][col_change]==1):
                        live_neighbours+=1
                if (copy_board[row][col]==1) and (live_neighbours<2 or live_neighbours>3):
                    board[row][col]=0
                if copy_board[row][col] == 0 and live_neighbours == 3:
                    board[row][col] = 1
# paste final accepted code here
```
