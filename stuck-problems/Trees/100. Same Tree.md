# 100.Same Tree

**LeetCode:** {https://leetcode.com/problems/same-tree/description/}  
**Date:** {2026-01-23}  
**Status:** âŒ Stuck / ðŸ” Redo  
**Difficulty:** Medium
**Tags/Pattern:** {trees}  
**Time/Space:** O(n) / O(h)

---

## 1) Problem in 1 line

find if the trees are structurally correct and values are equal of the nodes. if yes return true else return false.
Explain the problem in one sentence.

---

## 2) My first thought (before coding)

i have to use self function and recursion to check left and right subtrees. i should check if one tree exists and other doesnt case.
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook í•µì‹¬)

- Mistake #1:did not check the case where both the trees doesnt exist
- Mistake #2: function checks structure but using .val checks values. tried this but digressed.
- What I learned:
  p.val==q.val # value check

---

## 4) Final approach (in plain English)

if both trees dont exist return false
if both exist and vals are same check in same if condition then use self fuctions for both trees left and right traversal
use else for above if to return False #checks if one exists and other doesnt
Steps of the solution like youâ€™d explain to a friend.

---

## 5) Code (final)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
    #code i debugged and solved based on where i was getting struck
        if p and not q:
            return False
        if not p and q:
            return False
        if p and q:
            if p.val==q.val:
                return self.isSameTree(p.left, q.left) and self.isSameTree(p.right,q.right)
            else:
                return False
        if not p and not q:
            return True
# paste final accepted code here
```
