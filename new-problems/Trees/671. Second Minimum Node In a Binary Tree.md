# 671. Second Minimum Node In a Binary Tree

**LeetCode:** {https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/description/}  
**Date:** {2026-01-29}  
**Status:** ‚ùå Stuck / üîÅ Redo  
**Difficulty:** Easy
**Tags/Pattern:** {trees}  
**Time/Space:** O(n) / O(h)

---

## 1) Problem in 1 line

find the second min node in the whole tree
Explain the problem in one sentence.

---

## 2) My first thought (before coding)

i thought of taking count and result inorder to track nod evalues min as binary search tree but this scenario it is a binary tree
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook ÌïµÏã¨)

- Mistake #1:thought binary tree and binary search tree are same
- Mistake #2:
- What I learned:
- binary tree has two nodes irrespective of the order of values of the nodes
- binary search tree have nodes where all values in left subtree are strictly less than the node and right strictly greater than the node

---

## 4) Final approach (in plain English)

- take min value variable as roots value
- take second value variable as float positive infinite
- write helper function with input as node
- inside the function: if not node return, if min.val<node.val<second then assign node val as second val
- if node.val>= second then return as its not worth exploring node children which is greater than the second based on question condition
- call function with node.left and then node.right
- call helper function with root
- return second if not second is not equal to positive inf else -1
  Steps of the solution like you‚Äôd explain to a friend.

---

## 5) Code (final)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:
        self.min_val=root.val
        self.second=float('inf')
        if not root:
                return -1
        def search(node):
            if not node:
                return
            if self.min_val<node.val<self.second:
                self.second=node.val
            if node.val>=self.second:
                return
            search(node.left)
            search(node.right)
        search(root)
        return self.second if self.second!=float('inf') else -1


# paste final accepted code here
```
