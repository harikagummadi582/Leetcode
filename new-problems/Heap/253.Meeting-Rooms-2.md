# 253. meeting rooms 2

**LeetCode:** {https://leetcode.com/problems/meeting-rooms-ii/}  
**Date:** {2026-01-19}  
**Status:** ❌ Stuck
**Difficulty:** Medium
**Tags/Pattern:** heaps
**Time/Space:** O(?) / O(?)

---

## 1) Problem in 1 line

find the min number of conference rooms that can be allocated based on the meeting times
Explain the problem in one sentence.

---

## 2) My first thought (before coding)

i wanted to track end times to figure out but did not click post it
What I tried first, and why.

---

## 3) Mistakes / Confusions (Error Notebook 핵심)

- Mistake #1: did not know heaps can be used
- Mistake #2: sorting can be done based on start times to compare end time of before meeting with start time of current meeting to see allocation of the rooms
- What I learned:
  usage of lambda function to sort based on start time = intervals.sort(key=lambda x:x[0])
  heap usage = heapq.heappush(data structure like array, end time of the meeting)

---

## 4) Final approach (in plain English)

take free_rooms array
sort intervals based on each meeting start time
take for loop for tracking each meeting in intervals
now compare free_rooms top element <= end time of the meeting if yes pop top element so room can be reused
irrespective of above if new meeting end time will be added to the heap
return len of free_rooms
Steps of the solution like you’d explain to a friend.

---

## 5) Code (final)

```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        free_rooms=[] #have end times in increasing order; top having least
        intervals.sort(key=lambda x:x[0])
        heapq.heappush(free_rooms, intervals[0][1])
        for i in intervals[1:]:
            if free_rooms[0]<=i[0]:
                heappop(free_rooms)
            heappush(free_rooms, i[1])

        return len(free_rooms)
# paste final accepted code here
```
